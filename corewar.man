.TH Corewar 1 "August 16 2019" "Version 1.0" "Corewar man page"
.SH NAME
.PP
\fBCorewar\fR \-- Game in which programs fight against one another in a virtual "arena".
.SH SYNOPSIS
.PP
\fB./asm\fR \fIfile_name.s\fR
.br
\fB./corewar\fR [\fB-n\fR N] [\fB-dump\fR N] [\fB-v\fR N] [\fB-visu\fR] [\fB--stealth\fR] [\fB-a\fR] \fIfile_name.cor\fR \fI...\fR
.br
\fB./disassembler\fR \fIfile_name.cor\fR
.SH DESCRIPTION
.PP
The \fBCorewar\fR is a game that brings "players" together around a "virtual machine". 
This virtual machine will load some "champions" who will fight against one another with the support of "processes",
with the objective being for these champions to stay "alive". The game ends when all the processes are dead. 
The winner is the last player reported to be "alive".
.PP
The game is divided in three distinctive parts :
.TP
    \fIThe Assembler\fI
The Assembler compiles the champions and translates them into bytecode.
.TP
    \fIThe Virtual Machine\fI
The Virtual Machine loads the bytecode generated by the Assembler in an "arena".
.TP
    \fIThe Champion\fI
The Champion fights other programs in the "arena".
.TP
A Champion is composed of instructions, listed below :
.TP
\fBlive
Opcode \fI0x01\fR. Allows a process to stay alive. It can also record that the player whose number is the argument is indeed alive. No argument’s coding byte.
.TP
\fBld
Opcode \fI0x02\fR. Takes a random argument and a registry. Load the value of the first argument in the registry. It will change the carry.
.TP
\fBst
Opcode \fI0x03\fR. Takes a registry and a registry or an indirect and store the value of the registry toward a second argument.
.TP
\fBadd
Opcode \fI0x04\fR. Takes three registries, add the first two, and place the result in the third, right before modifying the carry.
.TP
\fBsub
Opcode \fI0x05\fR. Same as the add instruction, but uses a substraction.
.TP
\fBand
Opcode \fI0x06\fR. Apply an & (bit-to-bit AND) over the first two arguments and store the result in a registry, which is the third argument. Modifies the carry.
.TP
\fBor
Opcode \fI0x07\fR. Apply an | (bit-to-bit OR), in the same spirit and principle of the and instruction.
.TP
\fBxor
Opcode \fI0x08\fR. Apply an ^ (bit-to-bit XOR), acts like the and instruction but with an exclusive OR.
.TP
\fBzjmp
Opcode \fI0x09\fR. Takes an index and jumps to this address if the carry is 1.
.TP
\fBldi
Opcode \fI0x0A\fR. Uses 2 indexes and 1 registry, adding the first two, treating that like an address, reading a value of a registry’s size and putting it on the third.
.TP
\fBsti
Opcode \fI0x0B\fR. Takes a registry, and two indexes (potentially registries) add the two indexes, and uses this result as an address where the value of the first parameter will be copied.
.TP
\fBfork
Opcode \fI0x0C\fR. Takes an index, and creates a new process that will inherit the different states of its father, except its PC.
.TP
\fBlld
Opcode \fI0x0D\fR. Same as ld, but without % IDX_MOD. Modify the carry.
.TP
\fBlldi
Opcode \fI0x0E\fR. Same as ldi, but does not apply any modulo to the addresses. It will however, modify the carry.
.TP
\fBlfork
Opcode \fI0x0F\fR. Same as a fork without modulo in the address.
.TP
\fBaff
Opcode \fI0x10\fR. Takes a register as its only parameter writes the value of the register to the standard output.
.SH OPTIONS
.TP
\fB-n\fI N
Assign order N to next champion, default is : first champ is first to play
.TP
\fB-dump\fI N
Dumps memory after N cycles then exits
.TP
\fB-v\fI N
Verbosity levels, can be added together to enable several
 - 0 : Show only essentials
 - 1 : Show lives
 - 2 : Show cycles
 - 4 : Show operations (Params are NOT litteral ...)
 - 8 : Show deaths
 - 16 : Show PC movements (Except for jumps)
.TP
\fB-visu\fI
Ncurses output mode
.TP
\fB--stealth\fI
Competition mode, hide code with visual
.TP
\fB-a\fI
Prints output from "aff"
.SH EXAMPLES
"./asm 'zork.s'" Compile the champion zork.s in a file called zork.cor.
.br
"./corewar 'zork.cor' '42.cor' 'beegees.cor'" Launch the virtual machine with 'zork.cor', '42.cor' and 'beegees.cor' fighting each other.
.br
"./disassembler 'zork.cor'" Decompile the zork.cor file in a file called zork.s.
.SH SEE ALSO
No related manpage.
.SH BUGS
No known bugs.
.SH AUTHORS
syzhang, ratin, hlombard, gly.
.SH COPYRIGHT
Copyright (c) 2019 Sylvie Zhang.
