.TH Corewar 1 "August 16 2019" "Version 1.0" "Corewar man page"
.SH NAME
.PP
\fBCorewar\fR \-- Game in which programs fight against one another in a virtual "arena".
.SH SYNOPSIS
.PP
\fB./asm\fR [file_name.s]
.br
\fB./corewar\fR [\fB-n\fR] [\fB-dump\fR] [\fB-v\fR] [\fB-visu\fR] [\fB--stealth\fR]
.SH DESCRIPTION
.PP
The \fBCorewar\fR is a game that brings "players" together around a "virtual machine". 
This virtual machine will load some "champions" who will fight against one another with the support of "processes",
with the objective being for these champions to stay "alive". The game ends when all the processes are dead. 
The winner is the last player reported to be "alive".
.PP
The game is divided in three distinctive parts :
.TP
    \fIThe Assembler\fI
The Assembler compiles the champions and translates them into bytecode.
.TP
    \fIThe Virtual Machine\fI
The Virtual Machine loads the bytecode generated by the Assembler in an "arena".
.TP
    \fIThe Champion\fI
The Champion fights other programs in the "arena".
.TP
A Champion is composed of instructions, listed below :
.TP
\fBlive
Opcode 0x01. Allows a process to stay alive. It can also record that the player whose number is the argument is indeed alive. No argument’s coding byte.
.TP
\fBld
Opcode 0x02. Takes a random argument and a registry. Load the value of the first argument in the registry. It will change the carry.
.TP
\fBst
Opcode 0x03. Takes a registry and a registry or an indirect and store the value of the registry toward a second argument.
.TP
\fBadd
Opcode 0x04. Takes three registries, add the first two, and place the result in the third, right before modifying the carry.
.TP
\fBsub
Opcode 0x05. Same as the add instruction, but uses a substraction.
.TP
\fBand
Opcode 0x06. Apply an & (bit-to-bit AND) over the first two arguments and store the result in a registry, which is the third argument. Modifies the carry.
.TP
\fBor
Opcode 0x07. Apply an | (bit-to-bit OR), in the same spirit and principle of the and instruction.
.TP
\fBxor
Opcode 0x08. Apply an ^ (bit-to-bit XOR), acts like the and instruction but with an exclusive OR.
.TP
\fBzjmp
Opcode 0x09. Takes an index and jumps to this address if the carry is 1.
.TP
\fBldi
Opcode 0x0A. Uses 2 indexes and 1 registry, adding the first two, treating that like an address, reading a value of a registry’s size and putting it on the third.
.TP
\fBsti
Opcode 0x0B. Takes a registry, and two indexes (potentially registries) add the two indexes, and uses this result as an address where the value of the first parameter will be copied.
.TP
\fBfork
Opcode 0x0C. Takes an index, and creates a new process that will inherit the different states of its father, except its PC.
.TP
\fBlld
Opcode 0x0D. Same as ld, but without % IDX_MOD. Modify the carry.
.TP
\fBlldi
Opcode 0x0E. Same as ldi, but does not apply any modulo to the addresses. It will however, modify the carry.
.TP
\fBlfork
Opcode 0x0F. Same as a fork without modulo in the address.
.TP
\fBaff
Opcode 0x10. Takes a register as its only parameter writes the value of the register to the standard output.
.SH OPTIONS
.TP
\fB-n\fI N
Assign order N to next champion, default is : first champ is first to play
.TP
\fB-dump\fI N
Dumps memory after N cycles then exits
.TP
\fB-v\fI
Verbosity, print game informations
.TP
\fB-visu\fI
Ncurse visual
.TP
\fB--stealth\fI
Competition mode, hide code with visual
.SH EXAMPLES
"./asm 'zork.s'" Compile the champion zork.s in a file called zork.cor.
.br
"./corewar 'zork.cor' '42.cor' 'beegees.cor'" Launch the virtual machine with 'zork.cor', '42.cor' and 'beegees.cor' fighting each other.
.SH SEE ALSO
No related manpage.
.SH BUGS
No known bugs.
.SH AUTHORS
syzhang, ratin, hlombard, gly.
.SH COPYRIGHT
Copyright (c) 2019 Sylvie Zhang.